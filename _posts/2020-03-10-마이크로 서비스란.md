---
title: "마이크로서비스란?"
date: 2020-03-10
categories: Microservice
---

## 마이크로서비스 정의 및 특징
- 작고 자율적으로 협업하는 서비스
- 고도의 애자일(Agile)성, 변경 및 배포 신속성, 확장성을 확보할 수 있는 아키텍처 스타일
- IT 시스템을 자율적이고, 독립적이면서 느슨하게 연결된 아키텍처 스타일 또는 접근방식
- 다른 서비스에 의존성이 없고 배포와 관리를 단독으로 처리

## Monolithic Architecture 문제
 - 부분의 장애가 전체 서비스 장애로 확대 (Out Of Memory -> WAS shutdown)
 - 부분적인 Scale-out을 하기 어려움
 - 여러 컴포넌트가 하나의 서비스(또는 공통 모듈)에 강하게 결합 형태로 되어 있어 서비스의 변경 및 영향도 파악이 어려움
 - 작은 변경에도 높은 수준의 테스트 비용이 발생
 - 조직(개발자/팀)이 성장할수록, 배포의 대기 시간이 비약적으로 증가
 
 ![monolith](https://s2onion.github.io/asset/images/monolith-microservices.png)

## 마이크로서비스를 사용하는 이유 (장점)
- 빠르게 변화하는 시장에 대응하기 위한 비즈니스 요구 (Time to market)
  * 비즈니스 특정 부문에서 필요한 기능을 애자일(Agile)한 방식으로 개발하여 개발 주기 시간을 단축
  * 프로그램을 개발하는데 가장 적합한 도구를 자유롭게 선택이 가능
  * 시스템의 일부분의 교체 가능성을 극대화하여 교체에 드는 비용을 최소화
  * 처음부터 끝까지 비즈니스 기능 전체를 개발하지 않음
  * 지속적 통합 및 지속적 전달(CI/CD)을 통해 손쉽게 배포할 수 있고 문제가 발생할 경우 롤백 또한 쉬움
  * 자체적으로 데이터를 관리 (최적의 데이터베이스 기술과 스키마를 선택)

- 기술의 발전
  * REST API의 일반화
  * Docker와 같은 컨테이너 기술 발전
  * 클라우드 컴퓨팅 환경의 발전

![WhyMSA_1](https://s2onion.github.io/asset/images/WhyMSA_1.png)

## 마이크로서비스간의 통신
- 전송 방식에 대해 정해진 표준은 업음
- HTTP(RESTful), JMS, AMQP(메시지 프로토콜), Protocol Buffer, RPC, GRPC

## 마이크로서비스 특징
- 서비스 계약
  * 분명하게 정의된 서비스 계약에 의해 작성
  * 서비스 정의 기법으로 Swagger, JSON 스키마, WADL, RAML
- 서비스 호환성
  * 표준 프로토콜과 메시지 교환 표준을 준수하여 통신
  * REST/JSON은 호환성이 좋은 서비스를 개발하는 데 가장 널리 사용되는 방법
- 다양한 언어로 구성
  * Java, Go, Node.js, Shell
- 느슨한 결합
  * 독립적이고 이벤트로 입력을 받고 이벤트로 응답
  * 마이크로서비스 사이의 커뮤니케이션 수단으로 메시징, HTTP, REST 사용
- 서비스 재사용
  * 마이크로서비스는 전체를 재사용 가능
- 무상태
  * 마이크로서비스는 어떤 정보도 공유하지 않음
  * 상태관리는 데이터베이스나 인 메모리(Redis)를 이용
- 탐색 가능한 서비스
  * 자신의 존재를 스스로 드러내고 탐색에 의해 찾아지고 사용될 수 있음
  * 자신이 소속되어 있던 마이크로서비스 환경에서 스스로를 제거
  * Eureka / Zuul
- 가벼움
  * 서비스 하나에 책임도 하나
- 자동화
  * 개발 과정에서부터 운영에 이르기까지 전 과정을 최대한으로 자동화
  * 형상관리 : Git (GitLab)
  * 지속적 통합(CI, Continuous Integration): Jenkins, Travis
  * 테스트: 셀레늄(Selenium), 큐검버(Cucumber)
  * 구성 관리도구 : 앤서블(Ansible)
  * 배포 자동화: 쿠버네티스(Kubernetes), 메소스(Mesos), 마라톤(Marathon)
  * 빌드, 테스트, 배포, 확장 등 처음부터 끝까지 모든 과정을 자동화

## 마이크로서비스의 단점
- 모니터링
  * 다른 서비스를 호출할 수 있기 때문에 큰 규모에서는 서비스 호출을 추적하거나 서비스들을 모니터링하기 어려움
  * 장애가 발생할 경우 추적하는 것이 힘든 작업이 될 수 있음
- 프로세스간 통신
  * 다른 서비스를 REST API를 통해 소통하기 때문에 단일체의 프로세스간 통신에 비해 느림
- 디버깅
  * 서비스 호출이 다른 서비스를 연속적으로 호출하는 경우 디버깅이 어려움

## 마이크로서비스의 과제
- 운영 복잡도가 증가 (모니터링 및 관리해야 할 대상이 증가)
- 개발자도 운영 기술을 갖춰야 함 (DevOps)
- 서비스 인터페이스와 버전 관리
- 분산 시스템 구축의 복잡성
  * Network Latency
  * Fault tolerance (장애 허용 시스템)
  * Serialization (직렬화)
- 분리된 비-트랜잭션 시스템 설계의 어려움
- 서비스 인스턴스 찾기
- End to End 테스트
